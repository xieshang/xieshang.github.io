<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[C++]让SSCap成为我们的好帮手]]></title>
    <url>%2F2018%2F03%2F20%2F%E9%AB%98%E6%95%88%E7%9A%84SS-SSR%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[自从SS的出现，SSR的诞生，越来越多的SS系的出现，然后一个个的停更覆灭，其中的原因犹如传说一般，无法道明。对于我们来说，只是想出去看看动画片而已。 虽然现在的免费资源越来越多，也是越来越不稳定。于是乎，好多人早已自己去搬瓦工等等去自建服务器了，而对于我们这些抠门鬼，决然不会花这钱去折腾这些。 那么问题来，当手里拿到了一大把的服务器信息，我们如何去分辨它们的有效性？网上也提供很多方案，例如SSR设置为负载均衡、按次序模式，然后去刷谷歌这类链接多的网站，全部节点都测试过了，然后删除失败的。但是，很多服务器都是几个小时更换一次密码，如果用以上的方法，不是要每隔一段时间都要来那么一下？ 一直都有这样的困扰围绕着我。于是乎，没事就想看看是否有全自动/半自动的方法去测试并给出服务器的连接信息？无意间在逗比大侠的网站上看到了它——SSCap，它具有批量测试节点信息的功能： 下面是它的菜单界面，框起来的是我增加的功能。 增加的功能也是经历过好多次的更改。 【1】复制出可用的节点信息然后导入到SSR中，所以出现了“拷贝所有可用节点”； 【2】节点多了，太多失效节点，于是乎有了“删除不可用节点”； 【3】导入节点的时候，总是会遇到与原有节点重复的，那么必须来一个“删除相同节点”； 【4】人么，总是越来越懒的，最好是直接复制SS连接节点，一个功能直接实现——导入节点–&gt;删除相同节点–&gt;检测所有节点–&gt;删除不可用节点–&gt;拷贝所有节点，就出现了第一版的“自动”； 【5】每次导入到SSR都要先删了原来所有的节点，太麻烦了，有没有更好的方法呢？SSR的订阅功能可以有！呃。。。只能订阅在线的，本地文件不行，于是乎就有两个方法： 1、本地建立http服务； 2、上传到远程服务器； 3、修改SSR代码，使其支持本地文件订阅； 对于程序猿来说，必然是闲的蛋疼地选择了第3个了。于是就出现了“♥自动♥”： 导入节点–&gt;删除相同节点–&gt;检测所有节点–&gt;删除不可用节点–&gt;按SSR订阅格式导出节点信息到本地文件–&gt;执行run.bat 这里是想着预留一个后面接口，既然SSCap已经将信息都已经整理保存好了，那么以后还想蛋疼滴加点功能，就不用打开庞大的VS去码C++；这样也便于别人的功能定制。 再谈谈为何选择用cmd，不用exe\python等等其他方案，第一是因为cmd不需要建立运行环境，不像python这样需要建立环境才能运行；第二是cmd命令大部分人应该都多少接触过，入门不难，而且也可以很方便地调用别的方法，例如python\exe。 废话太多，源码详见：https://code.aliyun.com/xieshang/SSCap.git 成品：SSCap]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>番羽墙</tag>
        <tag>SSR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[穿鞋]看Youtube不再穿鞋了]]></title>
    <url>%2F2018%2F03%2F14%2F%E7%9C%8BYoutube%E4%B8%8D%E5%86%8D%E7%BF%BB%E5%A2%99%2F</url>
    <content type="text"><![CDATA[热衷于穿鞋看youtube而不停地找免费SS/SSR服务器的亲们有福利了，高速的镜像网站来了~~ 镜像1 镜像2 感谢 微兔光束 提供的免费资源]]></content>
      <categories>
        <category>穿鞋</category>
      </categories>
      <tags>
        <tag>youtube</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[油猴]小白写油猴脚本之free_ss脚本源码的编写[2018-3-19更新]]]></title>
    <url>%2F2018%2F03%2F01%2FTampermonkey_free_ss_plus%2F</url>
    <content type="text"><![CDATA[前言此篇文字完全为零基础，高手请绕道。。。 对于油猴的功能已经没必要解释太多，只能以神器来解释。 本人只是一个只会C(死皮赖脸地算个精通) \C++(打死多算也就算略懂皮毛) \VB(曾几何时也就这个拿得出收)的过时码农，对于JS\HTML……等等前端开发为空白码农。 曾几何时樱花docker盛行的时候，就在上面摆弄着ss/ssr服务器，也不存在这求人一说（可怜的点点工资供奉完奶粉后早已所剩无几）。自从樱花关闭众测后，也就步上了不停地找免费的资源的路上。自从找到了free-ss，自此也就安定下来了。 关注过free-ss的朋友肯定也了解过，提供的资源很多可能只有存活几个小时，时常要刷新、检测服务器的有效性，非常的麻烦，在后面我会再写一篇我的方法。 下面进入正题吧。 脚本思路 网页源码分析其实作者真的非常的煞费苦心，不止提供了那么多免费资源，还要不停地防止各种爬虫，隔三差五地更新代码，只是为了让我们这些手动党能够拿到自己需要的，其中的艰辛从源码中可见一斑。 从页面和源码都能看出，网站使用了表格table控件，那么，我们把它找出来。 获取表格并展示给用户选择将所有大于10的表格取出，并提取第一个数据展示给用户，由用户选择正确的信息，以便后面的选择。 获取有效的表格调试源码推荐使用火狐浏览器 取出所有成员大于10的表格并取出第一个信息，通过layer.open展示。 12345678910111213141516171819202122232425function choicetab() &#123; var j; var tab = document.getElementsByTagName("table"); var tabindex ,tabmax = 0, tabmaxnum = 0, goodtablen = 0; tabchoicetxt = "&lt;fieldset&gt;&lt;legend&gt;请选择正确的一条&lt;/legend&gt;&lt;form name='tabchoiceform'&gt;"; for(tabindex = 0; tabindex &lt; tab.length; tabindex++) &#123; print('表格' + tabindex + '长' + tab[tabindex].rows.length); if(tab[tabindex].rows.length &gt; 10) &#123; goodtab[goodtablen] = new Array(0); goodtab[goodtablen].push(tabindex); goodtab[goodtablen].push(tab[tabindex].rows[1].cells[1].innerHTML.toString()+'&amp;nbsp;&amp;nbsp;'+tab[tabindex].rows[1].cells[2].innerHTML.toString()+'&amp;nbsp;&amp;nbsp;'+tab[tabindex].rows[1].cells[3].innerHTML.toString()+'&amp;nbsp;&amp;nbsp;'+tab[tabindex].rows[1].cells[4].innerHTML.toString()); print(goodtab[goodtablen][0]); print(goodtab[goodtablen][1]); tabchoicetxt += genradioBox(goodtab[goodtablen][0], "tab_"+goodtab[goodtablen][0], goodtab[goodtablen][0], goodtab[goodtablen][1], "tab_group", false) + "&lt;br/&gt;"; goodtab.push(); goodtablen++; &#125; &#125; tabchoicetxt += "&lt;/fieldset&gt;"; print(tabchoicetxt);&#125; 展示选择信息，由用户选择并归档数据通过layer.open弹窗形式展示给客户，客户通过radioBox进行单选，无论选择正确错误都有数据，只是数据是否正确的问题。 12345678910111213askcheck: function () &#123; layer.open(&#123; type: 0, title:'请选择与页面相同的那条', area:['500px','200px'], btn:['确认','取消'], fixed: false, //不固定 yes:function()&#123; getselecttab(); &#125;, content: tabchoicetxt &#125;);&#125;, 数据、国家、加密方式的归档根据用户选择，采用逐行扫描的方式，将所有有效信息进行归档。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//判断用户选择function getselecttab()&#123; var choiceindex; var i; print("表格数："+goodtab.length); for(i = 0; i &lt; goodtab.length - 1; i++) &#123; print("判断表格：" + "input[parentIndex='tab_"+goodtab[i][0]+"']"); if($("input[parentIndex='tab_"+goodtab[i][0]+"']").is(':checked') == true) &#123; choiceindex = goodtab[i][0]; &#125; &#125; print("选择表格：" + choiceindex); gettab(choiceindex); check_box(); mainlayer();&#125;//读取选择的表格并归档数据(data_table)、国家(countrylist)、加密方式(encryptlist)function gettab(tabmax)&#123; var j; var tab = document.getElementsByTagName("table"); print('选择表格:' + tabmax); var tabindex ,tabmaxnum = 0, test = 0; print('表格' + tabmax + '最长'); s3 = tab[tabmax]; //获取第一个表格 ss_num = s3.rows.length; print('表格行数:' + ss_num); data_table = new Array(0); countrylist = new Array(0); encryptlist = new Array(0); for(var i = 0; i &lt; s3.rows.length - 1; i++)&#123; data_table[i] = new Array(0); var j; for(j = 0; j &lt; s3.rows[i + 1].cells.length - 1; j++)&#123; data_table[i].push(s3.rows[i + 1].cells[j].innerHTML.toString()); &#125; //获取国家列表 if(countrylist.length == 0) &#123; countrylist.push(data_table[i][6]); &#125;else&#123; for(j = 0; j &lt; countrylist.length; j++) &#123; if(countrylist[j] == data_table[i][6]) break; &#125; if(j == countrylist.length) &#123; countrylist.push(data_table[i][6]); print('c'+countrylist.length); &#125; &#125; //加密方式 if(encryptlist.length == 0) &#123; encryptlist.push(data_table[i][4]); &#125;else&#123; for(j = 0; j &lt; encryptlist.length; j++) &#123; if(encryptlist[j] == data_table[i][4]) break; &#125; if(j == encryptlist.length) &#123; encryptlist.push(data_table[i][4]); print('e'+encryptlist.length); &#125; &#125; &#125; print("服务器数量:"+data_table.length);&#125; 根据归档信息建立选择列表这里需要做两件事情： 1、根据归档的国家和加密方式列表建立html语言的ui； 2、使用弹窗layer.open进行展示； 效果如下图： 建立选择列表layer.open中的content支持html语言，所以需要一定的归档展示。这里涉及到一些简单的html标签，亲们自己去找相关的资料吧。 1234567891011121314151617181920212223242526272829function check_box() &#123; var i; ss_content += "&lt;fieldset&gt;&lt;legend&gt;国家&lt;/legend&gt;"; //建立国家列表 ss_content += "&lt;form name='countryform'&gt;"; for(i = 0; i &lt; countrylist.length; i++) &#123; ss_content += genCheckBox(i, "ct_"+i, i, countrylist[i], 0, true); ss_content += "&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"; &#125; ss_content += "&lt;/fieldset&gt;"; ss_content += "&lt;fieldset&gt;&lt;legend&gt;加密&lt;/legend&gt;"; //建立加密列表 for(i = 0; i &lt; encryptlist.length; i++) &#123; if(encryptlist[i].indexOf('gcm') &gt; -1 || encryptlist[i].indexOf('ctr') &gt; -1) &#123; ss_content += genCheckBox(i, "ec_"+i, i, encryptlist[i], 0, false); &#125;else&#123; ss_content += genCheckBox(i, "ec_"+i, i, encryptlist[i], 0, true); &#125; ss_content += "&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"; &#125; ss_content += "&lt;/fieldset&gt;"; print(ss_content);&#125; 通过弹窗展现通过layer.open将它们展现出来 1234567891011121314151617 function mainlayer() &#123; layer.open(&#123; type: 0,fixed: false, //不固定 title:'服务器('+ss_num+'条) ', area:['800px','300px'], btn:['复制'], yes:function()&#123; makecopydata(); var txt = ss_selecttxt; GM_setClipboard(txt); layer.msg('已复制到剪切板'); &#125;, content: ss_content &#125;); &#125; 根据选择筛选数据并导入到剪切板当用户点击复制时，执行筛选数据并导入到剪切板。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879function makecopydata() &#123; var i, j; ss_selecttxt = ''; var data = new Array(0); var unsel_country = new Array(0); var unsel_country_num = 0; var unsel_encrypt = new Array(0); var unsel_encrypt_num = 0; var max = 0; //筛选国家 print("没有选择的国家有"); for(i = 0; i &lt; countrylist.length; i++) &#123; if($("input[name='ct_"+i+"']").is(':checked') == false) &#123; unsel_country.push($("input[name='ct_"+i+"']").attr('alt')); unsel_country_num++; print(unsel_country[unsel_country.length - 1]); &#125; &#125; //筛选加密 print("没有选择的加密有"); for(i = 0; i &lt; encryptlist.length; i++) &#123; if($("input[name='ec_"+i+"']").is(':checked') == false) &#123; unsel_encrypt.push($("input[name='ec_"+i+"']").attr('alt')); unsel_encrypt_num++; print(unsel_encrypt[unsel_encrypt.length - 1]); &#125; &#125; if(unsel_country_num &gt; unsel_encrypt_num) &#123; max = unsel_country_num; &#125;else&#123; max = unsel_encrypt_num; &#125; print("开始筛选服务器"); ss_selecttxt = ''; for(i = 0; i &lt; data_table.length; i++) &#123; var need = 1; print(data_table[i][1] + "-" + data_table[i][6] + "-" + data_table[i][4]); for(j = 0; j &lt; max &amp;&amp; need; j++) &#123; if(j &lt; unsel_country_num) &#123; print("[国家]"+unsel_country[j]); //if(data_table[i][6] == unsel_country[j]) if(data_table[i][6].indexOf(unsel_country[j]) &gt; -1) &#123; need = 0; print("丢弃[国家]"+data_table[i][1]); continue; &#125; &#125; if(j &lt; unsel_encrypt_num) &#123; print("[加密]"+unsel_encrypt[j]); //if(data_table[i][4] == unsel_encrypt[j]) if(data_table[i][4].indexOf(unsel_encrypt[j]) &gt; -1) &#123; need = 0; print("丢弃[加密]"+data_table[i][1]); continue; &#125; &#125; &#125; if(need) &#123; var url1 = data_table[i][4]+':'+data_table[i][3]+'@'+data_table[i][1]+':'+data_table[i][2]; var url2 = 'ss://'+Base64.encodeURI(url1)+'#'+data_table[i][6]+'('+data_table[i][0]+')'; ss_selecttxt += url2 + '\r\n'; &#125; &#125;&#125; 2018-3-19 更新记录前几天因为有事一直没有碰过电脑，也不知道老师什么时候修改了表格的排序，所以又要更新代码，如果直接修改表格顺序，下次又小改一下，就又要更新代码，所以这里使用检测表格列名的方式动态确定表格的顺序，然后再根据判断做排列组合数据。 在gettab()函数中增加一下内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344tabsequence=new Array(6);//检测表格顺序并记录顺序：IP,PORT,PASS,METHOD,GLOBE(COUNTRY)for(i = 0; i &lt; 8; i++)&#123; print(s3.rows[0].cells[i].innerHTML.toString().toUpperCase()); //IP if(s3.rows[0].cells[i].innerHTML.toString().toUpperCase().indexOf("IP") &gt; -1) &#123; tabsequence[0] = i; print("IP:"+i); &#125; //PORT if(s3.rows[0].cells[i].innerHTML.toString().toUpperCase().indexOf("PORT") &gt; -1) &#123; tabsequence[1] = i; print("PORT:"+i); &#125; //PASS if(s3.rows[0].cells[i].innerHTML.toString().toUpperCase().indexOf("PASS") &gt; -1) &#123; tabsequence[2] = i; print("PASS:"+i); &#125; //METHOD if(s3.rows[0].cells[i].innerHTML.toString().toUpperCase().indexOf("METHOD") &gt; -1) &#123; tabsequence[3] = i; print("METHOD:"+i); &#125; //GLOBE if(s3.rows[0].cells[i].innerHTML.toString().toUpperCase().indexOf("GLOBE") &gt; -1) &#123; tabsequence[4] = i; print("GLOBE:"+i); &#125; //CLOCK if(s3.rows[0].cells[i].innerHTML.toString().toUpperCase().indexOf("CLOCK") &gt; -1) &#123; tabsequence[5] = i; print("CLOCK:"+i); &#125;&#125; 后面的相应代码就不赘述了，亲们有兴趣去看v0.0.8更新记录]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>油猴</tag>
      </tags>
  </entry>
</search>
